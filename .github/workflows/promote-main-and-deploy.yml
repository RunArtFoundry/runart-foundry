name: Promote main and deploy prod
on:
  workflow_dispatch:
    inputs:
      cleanup_workflow:
        description: "Crear PR para borrar este workflow temporal al finalizar"
        required: false
        default: "true"

jobs:
  promote-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
      pull-requests: write
    env:
      ACCOUNT_ID: a2c7fc66f00eab69373e448193ae7201
      CF_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      ACCESS_CLIENT_ID: ${{ secrets.ACCESS_CLIENT_ID }}
      ACCESS_CLIENT_SECRET: ${{ secrets.ACCESS_CLIENT_SECRET }}

    steps:
      - name: Checkout default branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Preflight Cloudflare token
        run: |
          set -e
          curl -sS -H "Authorization: Bearer $CF_TOKEN" https://api.cloudflare.com/client/v4/user/tokens/verify | jq -e '.success==true' >/dev/null

      - name: Ensure Pages project accessible
        run: |
          set -e
          curl -sS -H "Authorization: Bearer $CF_TOKEN" "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/pages/projects/runart-foundry" | jq -e '.success==true' >/dev/null

      - name: Create/Update main from chore/bootstrap-git
        run: |
          set -e
          # Traer refs necesarias
          git fetch origin chore/bootstrap-git main || git fetch origin chore/bootstrap-git
          # Crear/actualizar local main desde estado estable
          git checkout -B main origin/chore/bootstrap-git
          # Si origin/main existe y diverge, fusionar para evitar push no fast-forward (sin forzar)
          if git ls-remote --exit-code --heads origin main >/dev/null 2>&1; then
            echo "origin/main existe; realizando merge no destructivo (preferimos contenido estable actual)";
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git merge --no-edit -X ours origin/main || git merge --no-edit origin/main;
          fi
          # Empujar main a remoto de forma segura
          git push -u origin main
          echo "MAIN_HEAD=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Set default branch to main
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          set +e
          gh api -X PATCH repos/${{ github.repository }} -f default_branch=main
          STATUS=$?
          CURRENT=$(gh repo view --json defaultBranchRef --jq '.defaultBranchRef.name' || echo "unknown")
          if [ $STATUS -ne 0 ]; then
            echo "WARN: No se pudo cambiar default branch vía GITHUB_TOKEN (posible 403). Default actual: $CURRENT. Continuando…"
          else
            echo "Default branch cambiado correctamente. Actual: $CURRENT"
          fi

      - name: Align Cloudflare Pages production_branch = main
        run: |
          set -e
          curl -sS -X PATCH \
            -H "Authorization: Bearer $CF_TOKEN" -H "Content-Type: application/json" \
            --data '{"production_branch":"main"}' \
            "https://api.cloudflare.com/client/v4/accounts/${ACCOUNT_ID}/pages/projects/runart-foundry" \
            | jq -e '.success==true' >/dev/null

      - name: Re-list workflows
        env:
          GH_TOKEN: ${{ github.token }}
        run: gh workflow list

      - name: Run Pages Prod (workflow_dispatch)
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          # Intentar por filename primero, luego por nombre visible del workflow
          gh workflow run "pages-prod.yml" -f collect_evidence=true --ref main || gh workflow run "Deploy Production (Cloudflare)" -f collect_evidence=true --ref main
          echo "Esperando a que el run arranque…"; sleep 5
          # Intentar capturar el ID del run recién disparado (por filename)
          RUN_ID=$(gh run list --workflow "pages-prod.yml" --branch main --event workflow_dispatch --limit 1 --json databaseId,createdAt,status | jq -r '.[0].databaseId' || true)
          if [ -z "$RUN_ID" ] || [ "$RUN_ID" = "null" ]; then
            # Fallback por nombre visible del workflow
            RUN_ID=$(gh run list --workflow "Deploy Production (Cloudflare)" --branch main --event workflow_dispatch --limit 1 --json databaseId,createdAt,status | jq -r '.[0].databaseId' || true)
          fi
          if [ -z "$RUN_ID" ] || [ "$RUN_ID" = "null" ]; then
            echo "ERROR: No pude localizar el run ID de Pages Prod recién disparado" >&2
            echo "Últimos runs:" >&2
            gh run list --limit 5 >&2 || true
            exit 1
          fi
          echo "PAGES_PROD_RUN_ID=$RUN_ID" >> $GITHUB_ENV
          gh run watch "$RUN_ID" --exit-status

      - name: Capture last run URL
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ -z "${PAGES_PROD_RUN_ID:-}" ]; then
            echo "ERROR: PAGES_PROD_RUN_ID no está definido" >&2
            exit 1
          fi
          gh run view "$PAGES_PROD_RUN_ID" --json url -q .url | tee /tmp/prod_run_url.txt

      - name: Post-deploy smokes (Prod)
        run: |
          set -e
          SMOKES_STATUS="SKIPPED"
          HEALTH_JSON="/tmp/health_prod.json"
          WHOAMI_JSON="/tmp/whoami_prod.json"
          if [ -z "${ACCESS_CLIENT_ID:-}" ] || [ -z "${ACCESS_CLIENT_SECRET:-}" ]; then
            echo '{"skipped": true, "reason": "missing ACCESS_CLIENT_ID/ACCESS_CLIENT_SECRET"}' > "$HEALTH_JSON"
            echo '{"skipped": true, "reason": "missing ACCESS_CLIENT_ID/ACCESS_CLIENT_SECRET"}' > "$WHOAMI_JSON"
            echo "Auth smokes SKIPPED (missing secrets)"
          else
            set +e
            CODE=$(curl -sS -o /tmp/health_body.txt -w '%{http_code}' -H "CF-Access-Client-Id: $ACCESS_CLIENT_ID" -H "CF-Access-Client-Secret: $ACCESS_CLIENT_SECRET" https://runart-foundry.pages.dev/api/health)
            if [ "$CODE" = "200" ]; then
              if jq -e '.env=="production" and .ok==true' /tmp/health_body.txt >/dev/null 2>&1; then
                cp /tmp/health_body.txt "$HEALTH_JSON"
                HEALTH_OK=1
              else
                echo "{\"ok\":false,\"note\":\"JSON did not match expected\",\"body_preview\":$(head -c 400 /tmp/health_body.txt | jq -Rs .)}" > "$HEALTH_JSON"
              fi
            else
              echo "{\"ok\":false,\"http_code\":$CODE,\"note\":\"non-200 from Access or app\",\"body_preview\":$(head -c 400 /tmp/health_body.txt | jq -Rs .)}" > "$HEALTH_JSON"
            fi

            CODE2=$(curl -sS -o /tmp/whoami_body.txt -w '%{http_code}' -H "CF-Access-Client-Id: $ACCESS_CLIENT_ID" -H "CF-Access-Client-Secret: $ACCESS_CLIENT_SECRET" https://runart-foundry.pages.dev/api/whoami)
            if [ "$CODE2" = "200" ]; then
              if jq -e '.env=="production"' /tmp/whoami_body.txt >/dev/null 2>&1; then
                cp /tmp/whoami_body.txt "$WHOAMI_JSON"
                WHOAMI_OK=1
              else
                echo "{\"ok\":false,\"note\":\"JSON did not match expected\",\"body_preview\":$(head -c 400 /tmp/whoami_body.txt | jq -Rs .)}" > "$WHOAMI_JSON"
              fi
            else
              echo "{\"ok\":false,\"http_code\":$CODE2,\"note\":\"non-200 from Access or app\",\"body_preview\":$(head -c 400 /tmp/whoami_body.txt | jq -Rs .)}" > "$WHOAMI_JSON"
            fi
            set -e

            if [ "${HEALTH_OK:-0}" = "1" ] && [ "${WHOAMI_OK:-0}" = "1" ]; then
              SMOKES_STATUS="PASS"
              echo "Auth smokes PASS"
            else
              SMOKES_STATUS="NONBLOCKING-FAIL"
              echo "Auth smokes failed but non-blocking; captured evidence."
            fi
          fi
          echo "SMOKES_STATUS=$SMOKES_STATUS" >> $GITHUB_ENV

      - name: Save evidences and update 082
        run: |
          set -e
          TS=$(date -u +%Y%m%dT%H%M%SZ)
          DEST="apps/briefing/_reports/tests/T4_prod_smokes/$TS"
          mkdir -p "$DEST"
          cp /tmp/health_prod.json /tmp/whoami_prod.json "$DEST"/

          STATUS="${SMOKES_STATUS:-UNKNOWN}"
          case "$STATUS" in
            PASS)
              SMOKES_MSG="PASS (health env=production, whoami OK)" ;;
            NONBLOCKING-FAIL)
              SMOKES_MSG="NONBLOCKING-FAIL (Access/app check falló; ver body_preview en evidencias)" ;;
            SKIPPED)
              SMOKES_MSG="SKIPPED (missing ACCESS_CLIENT_ID/SECRET)" ;;
            *)
              SMOKES_MSG="UNKNOWN" ;;
          esac

          printf "# T4 Producción (post-switch a main)\n\n- Run: %s\n- Fecha (UTC): %s\n- Smokes: %s\n" "$(cat /tmp/prod_run_url.txt)" "$TS" "$SMOKES_MSG" > "$DEST/README.md"

          FILE="apps/briefing/docs/internal/briefing_system/ci/082_reestructuracion_local.md"
          mkdir -p "$(dirname "$FILE")"
          touch "$FILE"
          {
            echo ""
            echo "### [$(date -u +%Y-%m-%d)] — Switch a `main` + Pages producción alineada"
            echo "- Default branch: main"
            echo "- Pages: production_branch=main"
            echo "- Run Producción: $(cat /tmp/prod_run_url.txt)"
            echo "- Smokes post-deploy: $SMOKES_MSG"
            echo "- Evidencias: $DEST/"
            echo "- Notas: overlay activo en prod; KV validados."
            echo ""
          } >> "$FILE"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "$DEST" "$FILE"
          git commit -m "docs(ci): evidencias T4 prod + 082 update (post-switch to main)"
          git push

      - name: (Optional) Open PR to remove this temporary workflow
        if: ${{ inputs.cleanup_workflow == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          BR="chore/remove-temp-promote-workflow"
          git checkout -b "$BR"
          git rm .github/workflows/promote-main-and-deploy.yml
          git commit -m "ci: remove temporary promote-main-and-deploy workflow"
          git push -u origin "$BR"
          gh pr create --title "ci: remove temporary promote workflow" --body "Cleanup after promoting main and deploying prod" --base main
        
